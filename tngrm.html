<!DOCTYPE html>
<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (c) 2026 Ozgur Ulukir -->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zen Tangram - ≈ûekillerin Sanatƒ±nda Ustala≈üƒ±n</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700;900&family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    body {
      font-family: 'Nunito', 'Outfit', sans-serif;
    }

    #game-container {
      touch-action: none;
      background-color: #fcfaf8;
    }

    .btn-action {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .btn-action:hover {
      transform: translateY(-2px);
    }

    .btn-action:active {
      transform: translateY(0);
    }

    .win-overlay {
      display: none;
    }

    .win-overlay.active {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }
  </style>
</head>

<body class="min-h-screen bg-[#fcfaf8] flex items-center justify-center p-4">

  <!-- Win Overlay -->
  <div id="win-overlay"
    class="win-overlay group fixed inset-0 z-50 bg-stone-900/80 backdrop-blur-xl items-center justify-center opacity-0 pointer-events-none transition-all duration-700">
    <div class="bg-white p-12 rounded-[3rem] shadow-[0_32px_64px_-12px_rgba(0,0,0,0.3)] text-center max-w-sm mx-4 transform transition-all scale-90 duration-700 group-[.active]:scale-100">
      <div class="text-7xl mb-6 animate-bounce">‚ú®</div>
      <h2 class="text-4xl font-black text-stone-800 mb-2 tracking-tight">Harika!</h2>
      <p class="text-stone-500 font-medium mb-8">Par√ßalarƒ± <span id="win-time" class="text-stone-800 font-bold">00:00</span> i√ßinde m√ºkemmel bir ≈üekilde yerle≈ütirdiniz.</p>
      <div class="space-y-3">
        <button id="next-puzzle-btn"
          class="w-full py-4 bg-stone-900 text-white font-bold rounded-2xl hover:bg-stone-800 transition-all shadow-lg hover:shadow-stone-900/20 active:scale-95">Sƒ±radaki B√∂l√ºm</button>
        <button onclick="document.getElementById('win-overlay').classList.remove('active'); openLevelModal();"
          class="w-full py-4 bg-stone-100 text-stone-600 font-bold rounded-2xl hover:bg-stone-200 transition-all active:scale-95">B√∂l√ºm Haritasƒ±</button>
      </div>
    </div>
  </div>

  <!-- Level Modal -->
  <div id="level-modal"
    class="fixed inset-0 z-50 bg-stone-900/60 backdrop-blur-sm hidden items-center justify-center">
    <div class="bg-white p-8 rounded-[2.5rem] shadow-2xl w-full max-w-2xl mx-4 max-h-[80vh] flex flex-col">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-black text-stone-800 tracking-tight">B√∂l√ºm <span class="font-light">Se√ßin</span></h2>
        <button id="close-modal-btn" class="p-2 hover:bg-stone-100 rounded-full transition-colors text-2xl">‚úï</button>
      </div>
      <div id="level-list" class="grid grid-cols-2 md:grid-cols-3 gap-4 overflow-y-auto pr-2 custom-scrollbar">
        <!-- Levels will be injected here -->
      </div>
    </div>
  </div>

  <div
    class="bg-white/80 backdrop-blur-md rounded-[3rem] shadow-[0_32px_64px_-12px_rgba(0,0,0,0.08)] p-6 md:p-12 max-w-5xl w-full border border-white">
    <header class="flex flex-col md:flex-row justify-between items-start mb-12 gap-6">
      <div>
        <h1 class="text-4xl font-black text-stone-800 tracking-tight">ZEN <span class="font-light">TANGRAM</span></h1>
        <p class="text-stone-400 font-medium">S√ºr√ºkleyin, d√∂nd√ºr√ºn ve silueti olu≈üturun.</p>
      </div>
      <div class="flex flex-col items-end gap-2">
        <a href="editor.html" class="text-stone-500 hover:text-stone-800 underline text-sm">B√∂l√ºm D√ºzenleyici</a>
        <div class="flex items-center gap-4 bg-stone-50 p-2 rounded-2xl border border-stone-100">
          <button id="prev-btn"
            class="p-3 bg-white text-stone-600 hover:text-stone-900 rounded-xl shadow-sm border border-stone-200 transition-all hover:bg-stone-50">‚Üê</button>
          <button id="open-levels-btn" class="min-w-32 px-4 py-2 text-center text-stone-700 font-bold text-lg hover:bg-white rounded-lg transition-all">
            <span id="puzzle-name">Cat</span>
            <span class="block text-[10px] uppercase tracking-tighter text-stone-400 font-medium">B√∂l√ºmlere G√∂z At</span>
          </button>
          <button id="next-btn"
            class="p-3 bg-white text-stone-600 hover:text-stone-900 rounded-xl shadow-sm border border-stone-200 transition-all hover:bg-stone-50">‚Üí</button>
        </div>
        <div id="timer" class="text-stone-400 font-mono text-sm font-bold tracking-widest">00:00</div>
      </div>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-12 gap-10 items-start">
      <!-- Left Panel: Preview & Instructions -->
      <div class="lg:col-span-3 flex flex-col gap-8 order-2 lg:order-1">
        <div class="relative group">
          <div
            class="absolute -inset-1 bg-gradient-to-tr from-amber-200 to-amber-100 rounded-2xl blur opacity-25 group-hover:opacity-50 transition duration-1000">
          </div>
          <div
            class="relative bg-stone-900 rounded-2xl overflow-hidden shadow-xl aspect-square flex items-center justify-center">
            <div id="preview-container" class="w-full h-full"></div>
            <div
              class="absolute bottom-3 left-3 px-3 py-1 bg-white/10 backdrop-blur text-[10px] text-stone-400 rounded-full font-bold uppercase tracking-widest">
              Hedef Siluet</div>
          </div>
        </div>

        <div class="bg-white/50 p-6 rounded-[2rem] border border-stone-100 space-y-4 shadow-sm">
          <h3 class="text-stone-800 font-bold text-sm uppercase tracking-wider flex items-center gap-2">
            <span class="w-1.5 h-1.5 rounded-full bg-amber-500"></span> Kontroller
          </h3>
          <ul class="text-stone-500 text-sm space-y-3 font-medium">
            <li class="flex items-center gap-3">
              <span
                class="w-8 h-8 flex items-center justify-center bg-white border border-stone-200 rounded-lg text-stone-400">üñ±Ô∏è</span>
              Ta≈üƒ±mak i√ßin s√ºr√ºkle
            </li>
            <li class="flex items-center gap-3">
              <span
                class="w-8 h-8 flex items-center justify-center bg-white border border-stone-200 rounded-lg text-stone-400">2√ó</span>
              D√∂nd√ºrmek i√ßin √ßift tƒ±kla
            </li>
            <li class="flex items-center gap-3">
              <span
                class="w-8 h-8 flex items-center justify-center bg-white border border-stone-200 rounded-lg text-stone-400">‚å®Ô∏è</span>
              Oklar veya WASD ile ta≈üƒ±
            </li>
          </ul>
        </div>
      </div>

      <!-- Center Panel: Board -->
      <div class="lg:col-span-6 flex flex-col items-center gap-8 order-1 lg:order-2">
        <div class="relative w-full aspect-square max-w-[480px]">
          <div class="absolute -inset-4 bg-stone-200/40 rounded-[3rem] -rotate-2 scale-105"></div>
          <div id="game-container"
            class="relative bg-white rounded-[2.5rem] shadow-inner border-[12px] border-stone-900 overflow-hidden w-full aspect-square">
          </div>
        </div>
      </div>

      <!-- Right Panel: Piece Controls -->
      <div class="lg:col-span-3 flex flex-col gap-6 order-3">
        <div class="bg-stone-900 text-white p-8 rounded-[2.5rem] shadow-2xl space-y-8">
          <h3 class="text-stone-400 font-bold text-xs uppercase tracking-widest">Par√ßa ƒ∞≈ülemleri</h3>

          <div class="grid grid-cols-2 gap-3">
            <button id="rotate-left-btn"
              class="btn-action p-4 bg-stone-700 hover:bg-stone-600 rounded-xl flex flex-col items-center gap-2">
              <span class="text-xl">‚Ü∫</span>
              <span class="text-[10px] uppercase font-bold">Sol</span>
            </button>
            <button id="rotate-right-btn"
              class="btn-action p-4 bg-stone-700 hover:bg-stone-600 rounded-xl flex flex-col items-center gap-2">
              <span class="text-xl">‚Üª</span>
              <span class="text-[10px] uppercase font-bold">Saƒü</span>
            </button>
          </div>

          <button id="flip-btn"
            class="btn-action w-full py-4 bg-stone-700 hover:bg-stone-600 rounded-xl flex items-center justify-center gap-3">
            <span class="text-xl">‚Üî</span>
            <span class="text-[11px] uppercase font-bold tracking-wider">Par√ßayƒ± √áevir</span>
          </button>

          <hr class="border-stone-700">

          <div class="flex gap-2">
            <button id="check-btn"
              class="btn-action flex-[2] py-4 bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl shadow-[0_4px_15px_rgba(16,185,129,0.3)] flex items-center justify-center gap-3">
              <span class="text-xl">‚úì</span>
              <span class="text-[11px] uppercase font-bold tracking-wider">Doƒürula</span>
            </button>
            <button id="hint-btn"
              class="btn-action flex-1 py-4 bg-amber-500 hover:bg-amber-400 text-white rounded-xl shadow-[0_4px_15px_rgba(245,158,11,0.3)] flex items-center justify-center gap-2">
              <span class="text-lg">üí°</span>
              <span class="text-[10px] uppercase font-bold tracking-wider">ƒ∞pucu</span>
            </button>
          </div>

          <div class="flex gap-2">
            <button id="reset-btn"
              class="btn-action flex-1 py-3 bg-stone-900 hover:bg-stone-800 text-stone-400 text-[10px] uppercase font-bold rounded-xl border border-stone-700">Sƒ±fƒ±rla</button>
            <button id="solution-btn"
              class="btn-action flex-1 py-3 bg-stone-900 hover:bg-stone-800 text-stone-400 text-[10px] uppercase font-bold rounded-xl border border-stone-700">G√∂ster</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="js/constants.js"></script>
  <script>
    /**
     * KONVA.JS TANGRAM PUZZLE LOGIC
     */

    /**
     * GAME CONFIGURATION
     * Centralized configuration for easy tuning and maintenance
     */
    const CONFIG = {
      BOARD_SIZE: 450,
      SNAP_COORD: 15,
      ROTATION_STEP: 45,
      UNIT: 36,
      MAGNET: 20,
      PREVIEW_SIZE: 256,
      PREVIEW_SCALE_PADDING: 36,
      COMPARE_SIZE: 300,
      SIZE_TOLERANCE: 0.15,
      SIMILARITY_THRESHOLD: 0.97,
      SNAP_THRESHOLD: 5,
      SCALE_THRESHOLD: 0.1,
      KEYBOARD_DIST_NORMAL: 5,
      KEYBOARD_DIST_SHIFT: 1,
      FETCH_TIMEOUT: 10000,
      NOTIFICATION_DURATION: 5000,
      ANIMATION_HINT_DURATION: 0.6,
      ANIMATION_REVEAL_DURATION: 0.8,
      SHAKE_DURATION: 1000,
      SHAKE_AMPLITUDE: 5,
      DEBUG: false // Set to true for development logging
    };

    // Logger utility - suppresses logs in production
    const logger = {
      log: (...args) => {
        if (CONFIG.DEBUG) {
          console.log(...args);
        }
      },
      error: (...args) => {
        console.error(...args);
      },
      warn: (...args) => {
        console.warn(...args);
      }
    };

    // Aliases for backward compatibility
    const BOARD_SIZE = CONFIG.BOARD_SIZE;
    const SNAP_COORD = CONFIG.SNAP_COORD;
    const ROTATION_STEP = CONFIG.ROTATION_STEP;
    const UNIT = CONFIG.UNIT;
    const MAGNET = CONFIG.MAGNET;

    /**
     * MATRIX TRANSFORMATION UTILITY (Homogeneous Coordinates)
     * Inspired by "Representing 2D Transformations as Matrices"
     */
    const Mat33 = {
      identity: () => [1, 0, 0, 0, 1, 0, 0, 0, 1],
      multiply: (a, b) => {
        const res = new Array(9).fill(0);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            for (let k = 0; k < 3; k++) {
              res[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j];
            }
          }
        }
        return res;
      },
      translate: (tx, ty) => [1, 0, 0, 0, 1, 0, tx, ty, 1],
      rotate: (deg) => {
        const rad = deg * Math.PI / 180;
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [c, s, 0, -s, c, 0, 0, 0, 1];
      },
      scale: (sx, sy) => [sx, 0, 0, 0, sy, 0, 0, 0, 1],
      point: (m, p) => ({
        x: p.x * m[0] + p.y * m[3] + m[6],
        y: p.x * m[1] + p.y * m[4] + m[7]
      }),
      // Helper to generate a piece's transformation matrix
      getTransformMatrix: (x, y, r, sx, offX, offY) => {
        let m = Mat33.translate(-offX * UNIT, -offY * UNIT); // Pivot to origin
        m = Mat33.multiply(m, Mat33.scale(sx, 1));
        m = Mat33.multiply(m, Mat33.rotate(r));
        m = Mat33.multiply(m, Mat33.translate(x, y));
        return m;
      }
    };

    let PUZZLES = [];

    let stage, mainLayer, previewStage, previewLayer, currentPieces = [];
    let selectedPiece = null;
    let puzzleIndex = 0;
    let timerInterval;
    let secondsElapsed = 0;
    let hintAnimation = null; // Track animation to prevent memory leak
    let keydownHandler = null; // Track keydown listener to prevent leak

    function getPieceVertices(shape) {
      const def = PIECE_DEFS.find(d => d.id === shape.id());
      if (!def) return [];
      const tr = shape.getTransform();
      const pts = [];
      const scaleX = shape.scaleX();
      
      for (let i = 0; i < def.pts.length; i += 2) {
        // Apply scaleX to x-coordinate (handles flip for parallelogram)
        const x = def.pts[i] * UNIT * scaleX;
        const y = def.pts[i + 1] * UNIT;
        pts.push(tr.point({ x, y }));
      }
      return pts;
    }

    function getInitialPosition(index) {
      // Scatter pieces around the board
      const cols = 4;
      return {
        x: (index % cols) * 90 + 50,
        y: Math.floor(index / cols) * 90 + 300
      };
    }

    function init() {
      // Main Stage
      const container = document.getElementById('game-container');
      stage = new Konva.Stage({
        container: 'game-container',
        width: BOARD_SIZE,
        height: BOARD_SIZE
      });
      mainLayer = new Konva.Layer();
      stage.add(mainLayer);

      // Background click to deselect
      stage.on('click tap', (e) => {
        if (e.target === stage) {
          select(null);
        }
      });

      // Grid helper
      for (let i = 0; i < BOARD_SIZE; i += SNAP_COORD * 2) {
        mainLayer.add(new Konva.Line({ points: [i, 0, i, BOARD_SIZE], stroke: '#e5e7eb', strokeWidth: 1 }));
        mainLayer.add(new Konva.Line({ points: [0, i, BOARD_SIZE, i], stroke: '#e5e7eb', strokeWidth: 1 }));
      }

      // Preview Stage
      previewStage = new Konva.Stage({
        container: 'preview-container',
        width: 256,
        height: 256
      });
      previewLayer = new Konva.Layer();
      previewStage.add(previewLayer);

      setupPieces();

      // Load puzzles from JSON with timeout and error handling
      loadPuzzlesFromServer();

      setupEvents();

      window.addEventListener('resize', fitToContainer);
      fitToContainer();
    }

    async function loadPuzzlesFromServer() {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), CONFIG.FETCH_TIMEOUT);
      
      try {
        const response = await fetch('levels.json', { 
          signal: controller.signal,
          headers: { 'Cache-Control': 'no-cache' }
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        PUZZLES = data;

        // Load saved progress
        const savedIndex = localStorage.getItem('tangram_puzzle_index');
        puzzleIndex = savedIndex ? parseInt(savedIndex, 10) : 0;
        if (puzzleIndex >= PUZZLES.length) puzzleIndex = 0;

        loadPuzzle(puzzleIndex);
      } catch (err) {
        clearTimeout(timeoutId);
        logger.error('Error loading puzzles:', err);
        
        let errorMessage = 'Failed to load levels. ';
        if (err.name === 'AbortError') {
          errorMessage += 'Request timed out. Please check your connection.';
        } else {
          errorMessage += 'Please ensure the server is running.';
        }
        
        // Show user-friendly error notification
        showNotification(errorMessage, 'error');
      }
    }

    function showNotification(message, type = 'info') {
      // Create or get existing notification element
      let notification = document.getElementById('notification');
      if (!notification) {
        notification = document.createElement('div');
        notification.id = 'notification';
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 16px 24px;
          border-radius: 12px;
          font-weight: 600;
          font-size: 14px;
          z-index: 10000;
          transform: translateX(400px);
          transition: transform 0.3s ease-out;
          max-width: 400px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        `;
        document.body.appendChild(notification);
      }
      
      const bgColor = type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : '#6366f1';
      notification.style.backgroundColor = bgColor;
      notification.style.color = 'white';
      notification.textContent = message;
      
      // Animate in
      requestAnimationFrame(() => {
        notification.style.transform = 'translateX(0)';
      });
      
      // Auto dismiss after 5 seconds
      setTimeout(() => {
        notification.style.transform = 'translateX(400px)';
      }, CONFIG.NOTIFICATION_DURATION);
    }

    function fitToContainer() {
      const container = document.getElementById('game-container');
      const scale = container.offsetWidth / BOARD_SIZE;
      stage.width(container.offsetWidth);
      stage.height(container.offsetHeight);
      stage.scale({ x: scale, y: scale });
      stage.draw();
    }

    function setupPieces() {
      PIECE_DEFS.forEach((def, i) => {
        const initPos = getInitialPosition(i);
        const shape = new Konva.Line({
          points: def.pts.map(p => p * UNIT),
          fill: def.color,
          stroke: '#666',
          strokeWidth: 1.5,
          closed: true,
          draggable: true,
          id: def.id,
          name: 'piece',
          offset: { x: def.off[0] * UNIT, y: def.off[1] * UNIT },
          x: initPos.x,
          y: initPos.y,
          shadowColor: 'rgba(0,0,0,0.1)',
          shadowBlur: 5,
          shadowOffset: { x: 3, y: 3 },
          opacity: 0.95
        });

        shape.on('dragstart', () => {
          select(shape);
          shape.moveToTop(); // Bring to front when dragging starts
          shape.shadowOpacity(0.3).shadowOffset({ x: 10, y: 10 });
        });

        shape.on('dragmove', () => {
          let nearby = false;
          const thisPts = getPieceVertices(shape);

          for (let p of currentPieces) {
            if (p === shape) continue;
            const otherPts = getPieceVertices(p);
            for (let tp of thisPts) {
              for (let op of otherPts) {
                const dx = op.x - tp.x;
                const dy = op.y - tp.y;
                if (Math.sqrt(dx * dx + dy * dy) < MAGNET) {
                  nearby = true;
                  break;
                }
              }
              if (nearby) break;
            }
            if (nearby) break;
          }

          if (nearby) {
            shape.stroke('#ffffff');
            shape.strokeWidth(3);
          } else {
            shape.stroke('#000');
            shape.strokeWidth(3);
          }
        });

        shape.on('dragend', () => {
          handleSnap(shape);
          shape.stroke('#000');
          shape.strokeWidth(3);
        });

        shape.on('mouseenter', () => {
          document.body.style.cursor = 'grab';
          if (shape === selectedPiece) return;
          shape.to({
            scaleX: shape.scaleX() * 1.05,
            scaleY: 1.05,
            duration: 0.1
          });
          mainLayer.draw();
        });

        shape.on('mouseleave', () => {
          document.body.style.cursor = 'default';
          if (shape === selectedPiece) return;
          shape.to({
            scaleX: shape.scaleX() > 0 ? 1 : -1,
            scaleY: 1,
            duration: 0.1
          });
          mainLayer.draw();
        });

        shape.on('click tap', (e) => {
          e.cancelBubble = true;
          if (selectedPiece === shape) {
            select(null);
          } else {
            select(shape);
          }
        });
        
        // Handle double-click for desktop
        shape.on('dblclick', () => {
          shape.rotation(shape.rotation() + ROTATION_STEP);
          mainLayer.draw();
        });
        
        // Handle double-tap for mobile (prevent duplicate with dblclick)
        let lastTapTime = 0;
        shape.on('tap', (e) => {
          const now = Date.now();
          if (now - lastTapTime < 300 && now - lastTapTime > 50) {
            // Double tap detected (between 50ms and 300ms)
            shape.rotation(shape.rotation() + ROTATION_STEP);
            mainLayer.draw();
            e.cancelBubble = true;
          }
          lastTapTime = now;
        });

        mainLayer.add(shape);
        currentPieces.push(shape);
      });
    }

    function handleSnap(shape) {
      let snapped = false;
      const thisPts = getPieceVertices(shape);
      let best = { dist: Infinity, dx: 0, dy: 0 };

      currentPieces.forEach(p => {
        if (p === shape) return;
        const otherPts = getPieceVertices(p);
        thisPts.forEach(tp => {
          otherPts.forEach(op => {
            const dx = op.x - tp.x;
            const dy = op.y - tp.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < MAGNET && dist < best.dist) {
              best = { dist, dx, dy };
            }
          });
        });
      });

      if (best.dist < MAGNET) {
        shape.to({
          x: shape.x() + best.dx,
          y: shape.y() + best.dy,
          duration: 0.1,
          easing: Konva.Easings.EaseInOut,
          onFinish: () => {
            // Add a little pop effect
            shape.to({
              strokeWidth: 5,
              duration: 0.05,
              onFinish: () => {
                shape.to({ strokeWidth: 3, duration: 0.1 });
              }
            });
          }
        });
        snapped = true;
      }

      if (!snapped) {
        shape.position({
          x: Math.round(shape.x() / SNAP_COORD) * SNAP_COORD,
          y: Math.round(shape.y() / SNAP_COORD) * SNAP_COORD
        });
      }

      shape.shadowOpacity(0.1).shadowOffset({ x: 3, y: 3 });
      mainLayer.draw();
    }

    function select(piece) {
      // Deselect previous
      if (selectedPiece && selectedPiece !== piece) {
        selectedPiece.stroke('#666');
        selectedPiece.strokeWidth(1.5);
        selectedPiece.shadowBlur(5);
        selectedPiece.shadowColor('rgba(0,0,0,0.1)');
        selectedPiece.shadowOffset({ x: 3, y: 3 });
      }

      if (!piece) {
        if (selectedPiece) {
          // If we are just deselecting the current one (and piece is null)
          selectedPiece.stroke('#666');
          selectedPiece.strokeWidth(1.5);
          selectedPiece.shadowBlur(5);
          selectedPiece.shadowColor('rgba(0,0,0,0.1)');
          selectedPiece.shadowOffset({ x: 3, y: 3 });
          selectedPiece = null;
          mainLayer.draw();
        }
        return;
      }

      selectedPiece = piece;
      
      selectedPiece.stroke('#000');
      selectedPiece.strokeWidth(3);
      selectedPiece.shadowBlur(10);
      selectedPiece.shadowColor('rgba(0,0,0,0.2)');
      selectedPiece.shadowOffset({ x: 5, y: 5 });
      selectedPiece.moveToTop();
      
      mainLayer.draw();
    }

    function startTimer() {
      clearInterval(timerInterval);
      secondsElapsed = 0;
      updateTimerDisplay();
      timerInterval = setInterval(() => {
        secondsElapsed++;
        updateTimerDisplay();
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
    }

    function updateTimerDisplay() {
      const timerEl = document.getElementById('timer');
      if (!timerEl) return;
      
      const minutes = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
      const seconds = (secondsElapsed % 60).toString().padStart(2, '0');
      timerEl.textContent = `${minutes}:${seconds}`;
    }

    function loadPuzzle(idx) {
      if (PUZZLES.length === 0) return;
      puzzleIndex = (idx + PUZZLES.length) % PUZZLES.length;
      localStorage.setItem('tangram_puzzle_index', puzzleIndex);

      const p = PUZZLES[puzzleIndex];
      document.getElementById('puzzle-name').textContent = p.name;

      // Stop any existing timer and start fresh
      stopTimer();
      startTimer();

      previewLayer.destroyChildren();
      const group = new Konva.Group();

      Object.entries(p.sol).forEach(([id, s]) => {
        const def = PIECE_DEFS.find(d => d.id === id);
        // Use s directly as it now comes from JSON without the "config" wrapper
        // unless we wrapped it in JSON (which we didn't in my previous Write)
        const config = s; 
        group.add(new Konva.Line({
          points: def.pts.map(p => p * UNIT),
          fill: '#444',
          closed: true,
          x: config.x,
          y: config.y,
          rotation: config.r,
          scaleX: config.sx,
          offset: { x: def.off[0] * UNIT, y: def.off[1] * UNIT }
        }));
      });

      const box = group.getClientRect();
      const scale = 220 / Math.max(box.width, box.height);
      group.scale({ x: scale, y: scale });
      const newBox = group.getClientRect();
      group.position({
        x: (256 - newBox.width) / 2 - newBox.x + group.x(),
        y: (256 - newBox.height) / 2 - newBox.y + group.y()
      });

      previewLayer.add(group);
      previewLayer.draw();

      // Shake the first piece to guide the player
      if (hintAnimation) {
        hintAnimation.stop();
        hintAnimation = null;
      }
      
      setTimeout(() => {
        const firstPiece = currentPieces[0];
        if (firstPiece) {
          const startX = firstPiece.x();
          hintAnimation = new Konva.Animation((frame) => {
            firstPiece.x(startX + Math.sin(frame.time / 50) * CONFIG.SHAKE_AMPLITUDE);
          }, mainLayer);
          hintAnimation.start();
          setTimeout(() => {
            if (hintAnimation) {
              hintAnimation.stop();
              hintAnimation = null;
            }
            firstPiece.x(startX);
            mainLayer.draw();
          }, CONFIG.SHAKE_DURATION);
        }
      }, 500);
    }

    function setupEvents() {
      document.getElementById('rotate-left-btn').onclick = () => {
        if (!selectedPiece) return;
        selectedPiece.rotation(selectedPiece.rotation() - ROTATION_STEP);
        mainLayer.draw();
      };

      document.getElementById('rotate-right-btn').onclick = () => {
        if (!selectedPiece) return;
        selectedPiece.rotation(selectedPiece.rotation() + ROTATION_STEP);
        mainLayer.draw();
      };

      document.getElementById('flip-btn').onclick = () => {
        if (!selectedPiece) return;
        selectedPiece.scaleX(selectedPiece.scaleX() * -1);
        mainLayer.draw();
      };

      document.getElementById('prev-btn').onclick = () => loadPuzzle(puzzleIndex - 1);
      document.getElementById('next-btn').onclick = () => loadPuzzle(puzzleIndex + 1);
      document.getElementById('next-puzzle-btn').onclick = () => {
        document.getElementById('win-overlay').classList.remove('active');
        loadPuzzle(puzzleIndex + 1);
      };

      document.getElementById('reset-btn').onclick = reset;
      document.getElementById('solution-btn').onclick = reveal;
      document.getElementById('check-btn').onclick = checkSolution;
      document.getElementById('hint-btn').onclick = showHint;

      document.getElementById('open-levels-btn').onclick = openLevelModal;
      document.getElementById('close-modal-btn').onclick = closeLevelModal;

      // Remove existing keydown listener to prevent duplicates
      if (keydownHandler) {
        document.removeEventListener('keydown', keydownHandler);
      }

      keydownHandler = (e) => {
        if (!selectedPiece) return;
        const dist = e.shiftKey ? CONFIG.KEYBOARD_DIST_SHIFT : CONFIG.KEYBOARD_DIST_NORMAL;
        switch (e.key) {
          case 'ArrowLeft': case 'a': selectedPiece.x(selectedPiece.x() - dist); break;
          case 'ArrowRight': case 'd': selectedPiece.x(selectedPiece.x() + dist); break;
          case 'ArrowUp': case 'w': selectedPiece.y(selectedPiece.y() - dist); break;
          case 'ArrowDown': case 's': selectedPiece.y(selectedPiece.y() + dist); break;
        }
        mainLayer.draw();
      };

      document.addEventListener('keydown', keydownHandler);
    }

    function reset() {
      currentPieces.forEach((p, i) => {
        p.rotation(0);
        p.scaleX(1);
        p.position(getInitialPosition(i));
      });
      mainLayer.draw();
    }

    function reveal() {
      const sol = PUZZLES[puzzleIndex].sol;
      currentPieces.forEach(p => {
        const s = sol[p.id()];
        const config = s;
        p.to({
          x: config.x, y: config.y, rotation: config.r, scaleX: config.sx,
          duration: CONFIG.ANIMATION_REVEAL_DURATION * 1000, easing: Konva.Easings.EaseInOut
        });
      });
    }

    function showHint() {
      const sol = PUZZLES[puzzleIndex].sol;
      
      // Helper to normalize rotation to 0-360 range
      function normalizeRotation(rot) {
        return ((rot % 360) + 360) % 360;
      }
      
      // Find a piece that is not in its correct position
      const misplaced = currentPieces.find(p => {
        const s = sol[p.id()];
        const dx = Math.abs(p.x() - s.x);
        const dy = Math.abs(p.y() - s.y);
        const currentRot = normalizeRotation(p.rotation());
        const targetRot = normalizeRotation(s.r);
        // Consider shortest rotation direction (0¬∞ and 360¬∞ are equivalent)
        const rotationDiff = Math.min(Math.abs(currentRot - targetRot), 360 - Math.abs(currentRot - targetRot));
        const dsx = Math.abs(p.scaleX() - s.sx);
        return dx > CONFIG.SNAP_THRESHOLD || dy > CONFIG.SNAP_THRESHOLD || rotationDiff > CONFIG.SNAP_THRESHOLD || dsx > CONFIG.SCALE_THRESHOLD;
      });

      if (misplaced) {
        const s = sol[misplaced.id()];
        misplaced.to({
          x: s.x, y: s.y, rotation: s.r, scaleX: s.sx,
          duration: CONFIG.ANIMATION_HINT_DURATION * 1000, easing: Konva.Easings.EaseInOut,
          onFinish: () => {
            misplaced.stroke('#f59e0b');
            misplaced.strokeWidth(5);
            setTimeout(() => {
              misplaced.stroke('#000');
              misplaced.strokeWidth(3);
              mainLayer.draw();
            }, 1000);
          }
        });
      }
    }

    function checkSolution() {
      const sol = PUZZLES[puzzleIndex].sol;

      const compareSize = CONFIG.COMPARE_SIZE;
      const compareCenter = compareSize / 2;

      // --- Helper: Draw a set of pieces to a canvas ---
      function drawStateToCanvas(pieceStates, isSolutionData) {
        const canvas = document.createElement('canvas');
        canvas.width = compareSize;
        canvas.height = compareSize;
        const ctx = canvas.getContext('2d');
        
        // 1. Calculate Bounding Box
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        const polygons = [];

        Object.keys(pieceStates).forEach(key => {
          let id, config;
          if (isSolutionData) {
            id = key;
            config = pieceStates[key];
          } else {
            // pieceStates is an array of Konva Nodes
            const node = pieceStates[key];
            id = node.id();
            config = {
              x: node.x(),
              y: node.y(),
              r: node.rotation(),
              sx: node.scaleX()
            };
          }

          const def = PIECE_DEFS.find(d => d.id === id);
          if (!def) return;

          // Calculate vertices manually using Mat33
          const matrix = Mat33.getTransformMatrix(
            config.x, config.y, config.r, config.sx, 
            def.off[0], def.off[1]
          );

          const poly = [];
          for(let i=0; i<def.pts.length; i+=2) {
            const pt = Mat33.point(matrix, { x: def.pts[i] * UNIT, y: def.pts[i+1] * UNIT });
            poly.push(pt);
            if (pt.x < minX) minX = pt.x;
            if (pt.x > maxX) maxX = pt.x;
            if (pt.y < minY) minY = pt.y;
            if (pt.y > maxY) maxY = pt.y;
          }
          polygons.push(poly);
        });

        const width = maxX - minX;
        const height = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // 2. Draw centered
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        polygons.forEach(poly => {
          if (poly.length === 0) return;
          // Translate to canvas center
          const startX = poly[0].x - centerX + compareCenter;
          const startY = poly[0].y - centerY + compareCenter;
          ctx.moveTo(startX, startY);
          for(let i=1; i<poly.length; i++) {
            ctx.lineTo(poly[i].x - centerX + compareCenter, poly[i].y - centerY + compareCenter);
          }
          ctx.closePath();
        });
        ctx.fill();

        return { canvas, ctx, width, height };
      }

      const target = drawStateToCanvas(sol, true);
      const current = drawStateToCanvas(currentPieces, false);

      // --- Comparison Logic ---

      // 1. Aspect Ratio / Size Check
      const wDiff = Math.abs(target.width - current.width);
      const hDiff = Math.abs(target.height - current.height);

      if (wDiff > target.width * CONFIG.SIZE_TOLERANCE || hDiff > target.height * CONFIG.SIZE_TOLERANCE) {
        showNotification("The overall shape dimensions don't match. Check your edges!", 'error');
        return;
      }

      // 2. Pixel Difference Check using Jaccard Similarity
      const imgData1 = target.ctx.getImageData(0, 0, CONFIG.COMPARE_SIZE, CONFIG.COMPARE_SIZE).data;
      const imgData2 = current.ctx.getImageData(0, 0, CONFIG.COMPARE_SIZE, CONFIG.COMPARE_SIZE).data;

      let intersectionPixels = 0;
      let unionPixels = 0;
      let diffPixels = 0;

      for(let i = 3; i < imgData1.length; i += 4) {
        const alpha1 = imgData1[i] > 128 ? 1 : 0;
        const alpha2 = imgData2[i] > 128 ? 1 : 0;

        if (alpha1 || alpha2) {
          unionPixels++; // Pixel exists in either shape
          
          if (alpha1 && alpha2) {
            intersectionPixels++; // Pixel exists in both shapes
          } else {
            diffPixels++; // Pixel exists in only one shape
          }
        }
      }

      // Jaccard Similarity: intersection / union
      const jaccardSimilarity = unionPixels > 0 ? intersectionPixels / unionPixels : 0;
      
      // Require 97% similarity for a valid solution
      if (jaccardSimilarity >= CONFIG.SIMILARITY_THRESHOLD) {
        stopTimer();
        saveProgress(puzzleIndex, secondsElapsed);

        const minutes = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
        const seconds = (secondsElapsed % 60).toString().padStart(2, '0');
        document.getElementById('win-time').textContent = `${minutes}:${seconds}`;

        showNotification('Perfect match! Puzzle solved! üéâ', 'success');
        
        setTimeout(() => {
          document.getElementById('win-overlay').classList.add('active');
        }, 500);
      } else {
        const mismatchPercent = ((1 - jaccardSimilarity) * 100).toFixed(1);
        logger.log(`Shape mismatch: ${(jaccardSimilarity * 100).toFixed(2)}% similar, ${mismatchPercent}% different`);
        showNotification(`Not quite! ${mismatchPercent}% mismatch. Keep trying!`, 'error');
      }
    }

    function openLevelModal() {
      const modal = document.getElementById('level-modal');
      const list = document.getElementById('level-list');
      list.innerHTML = '';

      const progress = JSON.parse(localStorage.getItem('tangram_progress') || '{}');

      PUZZLES.forEach((p, i) => {
        const pData = progress[i];
        const btn = document.createElement('button');
        const isCurrent = i === puzzleIndex;
        const isCompleted = pData && pData.completed;

        btn.className = `group relative p-6 rounded-3xl border-2 text-left transition-all duration-300 ${isCurrent ? 'border-amber-400 bg-amber-50 shadow-lg scale-[1.02] z-10' : 'border-stone-100 hover:border-stone-200 hover:bg-stone-50'}`;

        const timeStr = pData ? `${Math.floor(pData.bestTime / 60).toString().padStart(2, '0')}:${(pData.bestTime % 60).toString().padStart(2, '0')}` : '--:--';

        btn.innerHTML = `
          <div class="flex justify-between items-start mb-2">
            <span class="text-[10px] text-stone-400 font-black uppercase tracking-widest">B√∂l√ºm ${i + 1}</span>
            ${isCompleted ? '<span class="text-emerald-500 text-sm">‚úì</span>' : ''}
          </div>
          <div class="text-xl font-black text-stone-800 mb-4">${p.name}</div>
          <div class="flex items-center gap-2 mt-auto">
            <span class="text-[10px] text-stone-400 font-bold uppercase tracking-widest">En ƒ∞yi S√ºre:</span>
            <span class="text-xs font-mono font-bold text-stone-600">${timeStr}</span>
          </div>
        `;
        btn.onclick = () => {
          loadPuzzle(i);
          closeLevelModal();
        };
        list.appendChild(btn);
      });

      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }

    function closeLevelModal() {
      const modal = document.getElementById('level-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    function saveProgress(idx, time) {
      try {
        const progress = JSON.parse(localStorage.getItem('tangram_progress') || '{}');
        if (!progress[idx]) {
          progress[idx] = { completed: true, bestTime: time };
        } else {
          progress[idx].completed = true;
          if (time < progress[idx].bestTime) {
            progress[idx].bestTime = time;
          }
        }
        localStorage.setItem('tangram_progress', JSON.stringify(progress));
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          logger.warn('LocalStorage quota exceeded. Clearing old data...');
          localStorage.removeItem('tangram_progress');
          // Retry with fresh storage
          saveProgress(idx, time);
        } else {
          logger.error('Failed to save progress:', e);
        }
      }
    }

    window.onload = init;
  </script>
</body>

</html>
